//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using WebDAVSharp.Data.HelperClasses;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using WebDAVSharp.Data.SQLObjects;
using WebDAVSharp.Server.Exceptions;
using WebDAVSharp.Data.Enums;
using WebDAVSharp.Data.Extensions;
using WebDAVSharp.Data.Security;

namespace WebDAVSharp.Data
{
    using System.Data.Entity.Migrations;

    public static class FolderEx
    {
        /// <summary>
        /// Validates that the folder name is valid (!!!Not Implemented!!!)
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="folderName"></param>
        /// <param name="context"></param>
        /// <returns></returns>
        public static string CheckFolderName(this Folder parent, string folderName, OnlineFilesEntities context = null)
        {
            return folderName;
          
        }

        /// <summary>
        /// Checks if the folder is checked out by a user.
        /// </summary>
        /// <param name="folder"></param>
        /// <returns></returns>
        public static bool IsCheckedOut(this Folder folder)
        {
            using (var context = new OnlineFilesEntities())
            {
                List<SpDoAnyChildrenHaveLocksResult> cellData =
                    context.Database.SqlQuery<SpDoAnyChildrenHaveLocksResult>($"dbo.sp_DoAnyChildrenHaveLocks '{folder.pk_FolderId}'").ToList();
                if (cellData.Any())
                {
                    if (cellData[0].Exists)
                        return true;
                }
                else
                    throw new WebDavNotFoundException("Shouldn't get here.");
            }
            return false;
        }

        /// <summary>
        /// Moves the folderId to this Folder
        /// folderId is the folder to move.
        /// </summary>
        /// <param name="destination"></param>
        /// <param name="folderId"></param>
        /// <param name="destinationName"></param>
        /// <param name="user"></param>
        public static void MoveFolderHere(this Folder destination, Guid folderId, string destinationName, Principal user)
        {
            using (var context = new OnlineFilesEntities())
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create folders at the destination location?
                if (destSecurity.Any(d => d.canCreateFolders && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    Folder folderToMove = context.Folders.Include(d => d.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderId);
                    if (folderToMove == null)
                        throw new Exception("Cannot move a non existant folder");

                    Folder parentToFolderToMove = context.Folders.Include(x => x.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderToMove.fk_ParentFolderId);
                    if (parentToFolderToMove == null)
                        throw new Exception("No parent to folder being moved.");

                    //Does the user have delete permission in the folder the item is comming from?
                    if (parentToFolderToMove.FolderSecurities.Any(d => user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId) && d.canDelete))
                    {
                        folderToMove.Name = destination.CheckFolderName(destinationName, context);
                        folderToMove.fk_ParentFolderId = destination.pk_FolderId;
                        context.SaveChanges();
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
        }

        /// <summary>
        /// Moves the fileId to this Folder
        /// </summary>
        /// <param name="destination"></param>
        /// <param name="fileId"></param>
        /// <param name="destinationName"></param>
        /// <param name="user"></param>
        public static void MoveFileHere(this Folder destination, Guid fileId, string destinationName, Principal user)
        {
            using (var context = new OnlineFilesEntities())
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create files in the destinatioin folder?
                if (destSecurity.Any(d => d.canCreateFiles && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    File fileToMove = context.Files.FirstOrDefault(d => d.pk_FileId == fileId);
                    if (fileToMove == null)
                        throw new Exception("Cannot move a non existant file");


                    Folder parentToFileToMove = context.Folders.Include(x => x.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == fileToMove.fk_FolderId);
                    if (parentToFileToMove == null)
                        throw new Exception("No parent to folder being moved.");

                    //Can the user delete from the folder that the file starts in?
                    if (parentToFileToMove.FolderSecurities.Any(d => user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId) && d.canDelete))
                    {
                        var locks = context.ObjectLockInfoes.Where(d => d.ObjectGuid == fileId);
                        if (locks.Count() > 0)
                        {
                            if (locks.Any(d => d.OwnerId == user.UserProfile.SecurityObjectId))
                            {
                                context.ObjectLockInfoes.RemoveRange(context.ObjectLockInfoes.Where(d => d.ObjectGuid == fileId));
                                context.SaveChanges();
                            }
                            else
                            {
                                throw new SecurityException("File is Locked by another user.");
                            }
                        }
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }


                    fileToMove.Name = destination.CheckFolderName(destinationName, context);
                    fileToMove.fk_FolderId = destination.pk_FolderId;
                    context.SaveChanges();
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
        }

        public static void RestoreFileHere(this Folder destination, Guid fileId, string destinationName, Principal user)
        {
            using (var context = new OnlineFilesEntities())
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create files in the destinatioin folder?
                if (destSecurity.Any(d => d.canCreateFiles && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    File fileToRestore = context.Files.FirstOrDefault(d => d.pk_FileId == fileId);
                    if (fileToRestore == null)
                        throw new Exception("Cannot move a non existant file");


                    Folder parentToFileToMove = context.Folders.Include(x => x.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == fileToRestore.fk_FolderId);
                    if (parentToFileToMove == null)
                        throw new Exception("No parent to folder being moved.");

                    //Can the user delete from the folder that the file starts in?
                    if (parentToFileToMove.FolderSecurities.Any(d => user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId) && d.canDelete))
                    {
                        var locks = context.ObjectLockInfoes.Where(d => d.ObjectGuid == fileId);
                        if (locks.Count() > 0)
                        {
                            if (locks.Any(d => d.OwnerId == user.UserProfile.SecurityObjectId))
                            {
                                context.ObjectLockInfoes.RemoveRange(context.ObjectLockInfoes.Where(d => d.ObjectGuid == fileId));
                                context.SaveChanges();
                            }
                            else
                            {
                                throw new SecurityException("File is Locked by another user.");
                            }
                        }
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }
                    fileToRestore.RestoreDeleted(PrincipleFactory.Instance.GetPrinciple().UserProfile);
                    fileToRestore.Name = destination.CheckFolderName(destinationName, context);
                    fileToRestore.fk_FolderId = destination.pk_FolderId;
                    context.SaveChanges();
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
        }

        public static void RestoreFolderHere(this Folder destination, Guid folderId, string destinationName, Principal user)
        {
            using (var context = new OnlineFilesEntities())
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create folders at the destination location?
                if (destSecurity.Any(d => d.canCreateFolders && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    Folder folderToRestore = context.Folders.Include(d => d.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderId);
                    if (folderToRestore == null)
                        throw new Exception("Cannot restore a non existant folder");

                    Folder parentToFolderToMove = context.Folders.Include(x => x.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderToRestore.fk_ParentFolderId);
                    if (parentToFolderToMove == null)
                        throw new Exception("No parent to folder being moved.");

                    //Does the user have delete permission in the folder the item is comming from?
                    if (parentToFolderToMove.FolderSecurities.Any(d => user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId) && d.canDelete))
                    {
                        folderToRestore.RestoreDeleted(PrincipleFactory.Instance.GetPrinciple().UserProfile);
                        folderToRestore.Name = destination.CheckFolderName(destinationName, context);
                        folderToRestore.fk_ParentFolderId = destination.pk_FolderId;
                        context.SaveChanges();
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
        }


        /// <summary>
        /// Copies the folderId to this Folder
        /// </summary>
        /// <param name="destination"></param>
        /// <param name="folderId"></param>
        /// <param name="destinationName"></param>
        /// <param name="user"></param>
        /// <param name="context"></param>
        /// <param name="recursive"></param>
        /// <param name="dbcxtransaction"></param>
        public static void CopyFolderHere(this Folder destination, Guid folderId, string destinationName, Principal user, OnlineFilesEntities context = null, bool recursive = true, DbContextTransaction dbcxtransaction = null)
        {
            bool createdContext = false;
            bool createdTransaction = false;
            bool didRollback = false;
            if (context == null)
            {
                createdContext = true;
                context = new OnlineFilesEntities();
            }


            if (dbcxtransaction == null)
            {
                dbcxtransaction = context.Database.BeginTransaction();
                createdTransaction = true;
            }
            try
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create folders at the destination location?
                if (destSecurity.Any(d => d.canCreateFolders && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    Folder folderToMove = context.Folders.Include(d => d.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderId);
                    if (folderToMove == null)
                        throw new Exception("Cannot move a non existant folder");

                    Folder parentToFolderToMove = context.Folders.Include(x => x.FolderSecurities).FirstOrDefault(d => d.pk_FolderId == folderToMove.fk_ParentFolderId);
                    if (parentToFolderToMove == null)
                        throw new Exception("No parent to folder being moved.");

                    //Does the user have read permission in the folder the item is comming from?
                    if (parentToFolderToMove.FolderSecurities.Any(d => user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId) && d.canListObjects))
                    {
                        Folder newFolder = Folder.Create(destinationName, destination.pk_FolderId, user.UserProfile, true);
                        context.SaveChanges();
                        if (recursive)
                        {
                            //Get all the files that are in the folder being copied.
                            var files = context.Files.Where(d => d.fk_FolderId == folderToMove.pk_FolderId);
                            foreach (File file in files)
                                newFolder.CopyFileHere(file.pk_FileId, file.Name, user, context, dbcxtransaction);
                            //Get all the folders inside the folder we are moving.
                            var folders = context.Folders.Where(d => d.fk_ParentFolderId == folderToMove.pk_FolderId);
                            //Copy the folders to the new location
                            foreach (var folder in folders)
                                newFolder.CopyFolderHere(folder.pk_FolderId, folder.Name, user, context, recursive, dbcxtransaction);
                        }
                        context.SaveChanges();
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
            catch (Exception)
            {
                if (createdTransaction)
                {
                    didRollback = true;
                    dbcxtransaction.Rollback();
                }
                throw;
            }

            finally
            {
                if (createdTransaction)
                {
                    if (!didRollback)
                        dbcxtransaction.Commit();
                    dbcxtransaction.Dispose();
                }
                if (createdContext)
                    context.Dispose();
            }

        }

        /// <summary>
        /// Copies the fileId to this Folder.
        /// </summary>
        /// <param name="destination"></param>
        /// <param name="fileId"></param>
        /// <param name="destinationName"></param>
        /// <param name="user"></param>
        /// <param name="context"></param>
        /// <param name="dbcxtransaction"></param>
        public static void CopyFileHere(this Folder destination, Guid fileId, string destinationName, Principal user, OnlineFilesEntities context = null, DbContextTransaction dbcxtransaction = null)
        {
            bool createdContext = false;
            bool createdTransaction = false;
            bool didRollback = false;
            if (context == null)
            {
                createdContext = true;
                context = new OnlineFilesEntities();
            }
            if (dbcxtransaction == null)
            {
                dbcxtransaction = context.Database.BeginTransaction();
                createdTransaction = true;
            }
            try
            {
                var destSecurity = context.FolderSecurities.Where(d => d.fk_FolderId == destination.pk_FolderId);

                //Can the user create files at the destination location?
                if (destSecurity.Any(d => d.canCreateFiles && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    var file = context.Files
                        .Include(x => x.FileSecurities)
                        .Include(x => x.FileDatas)
                        .FirstOrDefault(d => d.pk_FileId == fileId);

                    //Can the user Read the file to be copied?
                    if (file.FileSecurities.Any(f => user.UserProfile.mySecurityGroups.Contains(f.SecurityObjectId) && f.canRead))
                    {
                        File newFile = File.Create(destination.pk_FolderId, file.Name, user.UserProfile, true);
                        context.SaveChanges();

                        //Copy the file data
                        using (Stream s = file.OpenReadStream(user))
                        using (Stream d = newFile.OpenWriteStream(user))
                            s.CopyTo(d);

                        //Copy the file Security
                        foreach (FileSecurity security in file.FileSecurities)
                        {
                            FileSecurity nsec = context.FileSecurities.FirstOrDefault(d => d.fk_FileId == newFile.pk_FileId && d.SecurityObjectId == security.SecurityObjectId);
                            if (nsec == null)
                            {

                                nsec = new FileSecurity()
                                {
                                    canRead = security.canRead,
                                    canWrite = security.canWrite,
                                    CanDelete = security.CanDelete,
                                    fk_FileId = newFile.pk_FileId,
                                    SecurityObjectId = security.SecurityObjectId
                                };
                                context.FileSecurities.Add(nsec);
                            }
                            else
                            {
                                nsec.canRead = nsec.canRead || security.canRead;
                                nsec.CanDelete = nsec.CanDelete || security.CanDelete;
                                nsec.canWrite = nsec.canWrite || security.canWrite;
                            }
                        }
                        context.SaveChanges();
                    }
                    else
                    {
                        throw new SecurityException("Not Authorized.");
                    }

                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
            catch (Exception)
            {
                //If we got an error and we created the transaction, roll it back.
                if (createdTransaction)
                {
                    dbcxtransaction.Rollback();
                    didRollback = true;
                }
                throw;
            }

            finally
            {
                if (createdTransaction)
                {
                    //If we didn't roll back the transaction, commit it.
                    if (!didRollback)
                        dbcxtransaction.Commit();
                    dbcxtransaction.Dispose();
                }
                if (createdContext)
                    context.Dispose();
            }

        }


    }

    public partial class Folder : IFileSystemObject

    {
        public IFileSystemObject GetInfo()
        {
            return  this;
        }

        public SqlStoreFileInfo GetFolderInfo()
        {
            var fileinfo = new SqlStoreFileInfo
            {
                Parent = null,
                Path = null,
                Exists = true,
                CreationTime = CreateDt,
                LastAccessTime = CreateDt,
                LastWriteTime = null,
                Directory = false,
                Archive = GetWin32Attribute(FileAttributes.Archive),
                Compressed = GetWin32Attribute(FileAttributes.Compressed),
                Device = GetWin32Attribute(FileAttributes.Device),
                Encrypted = GetWin32Attribute(FileAttributes.Encrypted),
                NotContentIndexed = GetWin32Attribute(FileAttributes.NotContentIndexed),
                Offline = GetWin32Attribute(FileAttributes.Offline),
                System = GetWin32Attribute(FileAttributes.System),
                Hidden = GetWin32Attribute(FileAttributes.Hidden),
                IntegrityStream = GetWin32Attribute(FileAttributes.IntegrityStream),
                NoScrubData = GetWin32Attribute(FileAttributes.NoScrubData),
                Normal = GetWin32Attribute(FileAttributes.Normal),
                ReadOnly = GetWin32Attribute(FileAttributes.ReadOnly),
                ReparsePoint = GetWin32Attribute(FileAttributes.ReparsePoint),
                SparseFile = GetWin32Attribute(FileAttributes.SparseFile),
                Temporary = GetWin32Attribute(FileAttributes.Temporary),
                ObjectGuid = pk_FolderId
            };
            return fileinfo;
        }
        /// <summary>
        /// Returns the bit flag to a file attribute.
        /// </summary>
        /// <param name="attrib"></param>
        /// <returns></returns>
        public bool GetWin32Attribute(FileAttributes attrib) => FlagsHelper.IsSet((FileAttributes)Win32FileAttribute, attrib);

        /// <summary>
        /// Sets a bit flag to a file attribute.
        /// </summary>
        /// <param name="user"></param>
        /// <param name="attrib"></param>
        /// <param name="value"></param>
        public void SetWin32Attribute(FileAttributes attrib, bool value)
        {
            if (value)
                Win32FileAttribute = (int)FlagsHelper.Set(((FileAttributes)Win32FileAttribute), attrib);
            else
                Win32FileAttribute = (int)FlagsHelper.Unset(((FileAttributes)Win32FileAttribute), attrib);


        }

        /// <summary>
        /// Creates a new Folder object.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="parentFolderGuid"></param>
        /// <param name="createdBy"></param>
        /// <param name="inheritSecurity"></param>
        /// <param name="isSystemCreate"></param>
        /// <returns></returns>
        public static Folder Create(string name, Guid? parentFolderGuid, SecurityObject createdBy, bool inheritSecurity = true, bool isSystemCreate = false)
        {
            using (var context = new OnlineFilesEntities())
            {
                //Get Folder object for parent folder
                Folder parentFolder = context.Folders
                    .Include(x => x.CatalogCollection)
                    .Include(x => x.FolderSecurities)
                    .FirstOrDefault(d => d.pk_FolderId == parentFolderGuid);

                if (!isSystemCreate)
                    if (!(parentFolder.FolderSecurities.Any(x => createdBy.mySecurityGroups.Contains(x.SecurityObjectId) && x.canCreateFolders)))
                        throw new SecurityException("Not Authorized.");


                //Check Name
                name = parentFolder.CheckFolderName(name);

                //If Parent Folder is null, throw exception
                if (parentFolder == null)
                    throw new Exception("Folder is null");


                //Create Folder
                Folder f = new Folder
                {
                    fk_ParentFolderId = parentFolderGuid,
                    Name = name,
                    CreateDt = DateTime.Now,
                    fk_CatalogCollectionId = parentFolder.fk_CatalogCollectionId,
                    Win32FileAttribute = (int)FileAttributes.Directory,
                    IsDeleted = false,
                    DeletedDt = null,
                    DeletedBy = null,
                    OwnerId = createdBy.SecurityObjectId,
                    CreatedById = createdBy.SecurityObjectId
                };
                try
                {
                    context.Folders.Add(f);
                    context.SaveChanges();
                    var pfs = new FolderSecurity()
                    {
                        canDelete = true,
                        canListObjects = true,
                        canCreateFiles = true,
                        canCreateFolders = true,
                        canChangePermissions = true,
                        fk_FolderId = f.pk_FolderId,
                        SecurityObjectId = createdBy.SecurityObjectId
                    };
                    context.SaveChanges();


                    if (inheritSecurity)
                    {
                        foreach (FolderSecurity fs in parentFolder.FolderSecurities)
                        {
                            FolderSecurity folderSecurity = new FolderSecurity()
                            {
                                SecurityObjectId = fs.SecurityObjectId,
                                fk_FolderId = f.pk_FolderId,
                                canCreateFolders = fs.canCreateFolders,
                                canDelete = fs.canDelete,
                                canChangePermissions = fs.canChangePermissions,
                                canCreateFiles = fs.canCreateFiles,
                                canListObjects = fs.canListObjects
                            };
                            context.FolderSecurities.Add(folderSecurity);
                        }

                        context.SaveChanges();

                        FolderSecurity us = context.FolderSecurities.FirstOrDefault(d => d.fk_FolderId == f.pk_FolderId && d.SecurityObjectId == createdBy.SecurityObjectId);
                        if (us == null)
                        {
                            us = new FolderSecurity()
                            {
                                canListObjects = true,
                                canChangePermissions = true,
                                canCreateFiles = true,
                                canCreateFolders = true,
                                canDelete = true,
                                fk_FolderId = f.pk_FolderId,
                                SecurityObjectId = createdBy.SecurityObjectId
                            };
                            context.FolderSecurities.Add(us);
                        }
                        else
                        {
                            us.canListObjects = true;
                            us.canChangePermissions = true;
                            us.canCreateFolders = true;
                            us.canCreateFiles = true;
                            us.canDelete = true;
                        }
                        context.SaveChanges();
                    }
                }
                catch (Exception ex)
                {
                    throw new Exception("Unable to create new folder.", ex);
                }
                return f;
            }



        }

        /// <summary>
        /// Marks the Folder object as deleted, don't forget to commitchanges.
        /// </summary>
        /// <param name="deletedBy"></param>
        public void SetDeleted(SecurityObject deletedBy)
        {
            List<FolderSecurity> perm;
            using (var context = new OnlineFilesEntities())
                perm = context.FolderSecurities.AsNoTracking().Where(d => d.fk_FolderId == pk_FolderId).ToList();

            if (perm.Any(d => d.canDelete && deletedBy.mySecurityGroups.Contains(d.SecurityObjectId)))
            {
                IsDeleted = true;
                DeletedDt = DateTime.Now;
                DeletedById = deletedBy.SecurityObjectId;
            }
            else
            {
                throw new SecurityException("Not Authorized.");
            }
        }

        /// <summary>
        /// Marks the Folder object as deleted, don't forget to commitchanges.
        /// </summary>
        /// <param name="deletedBy"></param>
        public void SetDeleted(Principal deletedBy)
        {
            List<FolderSecurity> perm;
            using (var context = new OnlineFilesEntities())
                perm = context.FolderSecurities.AsNoTracking().Where(d => d.fk_FolderId == pk_FolderId).ToList();

            if (perm.Any(d => d.canDelete && deletedBy.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
            {
                IsDeleted = true;
                DeletedDt = DateTime.Now;
                DeletedById = deletedBy.UserProfile.SecurityObjectId;
            }
            else
            {
                throw new SecurityException("Not Authorized.");
            }
        }

        public void RestoreDeleted(SecurityObject undeletedBy)
        {
            List<FolderSecurity> perm;
            using (var context = new OnlineFilesEntities())
                perm = context.FolderSecurities.AsNoTracking().Where(d => d.fk_FolderId == pk_FolderId).ToList();

            if (perm.Any(d => d.canDelete && undeletedBy.mySecurityGroups.Contains(d.SecurityObjectId)))
            {
                IsDeleted = false;
                DeletedDt = DateTime.Now;
                DeletedById = undeletedBy.SecurityObjectId;
            }
            else
            {
                throw new SecurityException("Not Authorized.");
            }
        }


        /// <summary>
        /// Will set the permissions for the targetUser, use recursive if you want it to propagate to child file and folders.
        /// context & dbcxtransaction should be null.
        /// </summary>
        /// <param name="FolderId"></param>
        /// <param name="user"></param>
        /// <param name="targetUser"></param>
        /// <param name="canListObjects"></param>
        /// <param name="canCreateFiles"></param>
        /// <param name="canCreateFolders"></param>
        /// <param name="canDelete"></param>
        /// <param name="canChangePermissions"></param>
        /// <param name="recursive"></param>
        /// <param name="context"></param>
        /// <param name="dbcxtransaction"></param>
        public static void SetPermissions(Guid FolderId, Principal user, Principal targetUser, bool canListObjects, bool canCreateFiles, bool canCreateFolders, bool canDelete, bool canChangePermissions, bool recursive = false, OnlineFilesEntities context = null, DbContextTransaction dbcxtransaction = null)
        {

            bool createdContext = false;
            bool createdTransaction = false;
            bool didRollback = false;
            if (context == null)
            {
                createdContext = true;
                context = new OnlineFilesEntities();
            }


            if (dbcxtransaction == null)
            {
                dbcxtransaction = context.Database.BeginTransaction();
                createdTransaction = true;
            }
            try
            {
                Folder target = context.Folders
                    .Include(d => d.FolderSecurities)
                    .FirstOrDefault(d => d.pk_FolderId == FolderId);

                //Can the user Change Permissions
                if (target.FolderSecurities.Any(d => d.canChangePermissions && user.UserProfile.mySecurityGroups.Contains(d.SecurityObjectId)))
                {
                    var secRecord = target.FolderSecurities.FirstOrDefault(d => d.SecurityObjectId == targetUser.UserProfile.SecurityObjectId);
                    if (secRecord == null)
                    {
                        secRecord = new FolderSecurity()
                        {
                            SecurityObjectId = targetUser.UserProfile.SecurityObjectId,
                            canChangePermissions = canChangePermissions,
                            canListObjects = canListObjects,
                            canCreateFolders = canCreateFolders,
                            canCreateFiles = canCreateFiles,
                            canDelete = canDelete,
                            fk_FolderId = target.pk_FolderId
                        };
                        target.FolderSecurities.Add(secRecord);
                    }
                    else
                    {
                        secRecord.canListObjects = canListObjects;
                        secRecord.canChangePermissions = canChangePermissions;
                        secRecord.canCreateFiles = canCreateFiles;
                        secRecord.canCreateFolders = canCreateFolders;
                        secRecord.canDelete = canDelete;
                    }
                    foreach (File source in context.Files.Where(d => d.fk_FolderId == target.pk_FolderId))
                        File.SetPermissions(source.pk_FileId, user, targetUser, canListObjects, canCreateFiles, canDelete, context, dbcxtransaction);

                    context.SaveChanges();
                    if (recursive)
                        foreach (Folder folder in context.Folders.Where(d => d.fk_ParentFolderId == target.pk_FolderId))
                            SetPermissions(folder.pk_FolderId, user, targetUser, canListObjects, canCreateFiles, canCreateFolders, canDelete, canChangePermissions, recursive, context, dbcxtransaction);
                }
                else
                {
                    throw new SecurityException("Not Authorized.");
                }
            }
            catch (Exception)
            {
                if (createdTransaction)
                {
                    didRollback = true;
                    dbcxtransaction.Rollback();
                }
                throw;
            }

            finally
            {
                if (createdTransaction)
                {
                    if (!didRollback)
                        dbcxtransaction.Commit();
                    dbcxtransaction.Dispose();
                }
                if (createdContext)
                    context.Dispose();
            }



        }

        /// <summary>
        /// Rename the object
        /// </summary>
        /// <param name="targetFolderId"></param>
        /// <param name="folderId"></param>
        /// <param name="name"></param>
        /// <param name="createdBy"></param>
        /// <returns></returns>
        public static Folder Rename(Guid? targetFolderId, Guid? folderId, string name, SecurityObject createdBy)
        {
            using (var context = new OnlineFilesEntities())
            {
                if (folderId == null)
                    throw new Exception("Bad Guid.");

                var folder = context.Folders
                    .Include(x => x.FolderSecurities)
                    .FirstOrDefault(d => d.pk_FolderId == folderId);
                if (folder == null)
                    throw new Exception("Folder Not Found.");

                if (!folder.FolderSecurities.Any(x => createdBy.mySecurityGroups.Contains(x.SecurityObjectId) && x.canCreateFiles))
                    throw new SecurityException("No Access.");

                var folderchk = context.Folders
                .Include(x => x.FolderSecurities)
                .FirstOrDefault(d => d.Name == name);
                if (folderchk != null)
                    throw new Exception("Folder Name already used.");
                var foldername = context.Folders
                    .Include(x => x.FolderSecurities)
                    .FirstOrDefault(d => d.pk_FolderId == targetFolderId);
                if (foldername != null)
                    foldername.Name = name;

                context.Folders.AddOrUpdate(foldername);
                context.SaveChanges();

                return foldername;
            }
        }

        public SqlStoreFileInfo DosFileInfo => GetFolderInfo();
        public FileSystemObjectType ObjectType => FileSystemObjectType.File;


        private long _Size(Guid folderId)
        {
            long size = 0;
            using (var context = new OnlineFilesEntities())
            {
                foreach (Folder folder in context.Folders.Where(d => d.fk_ParentFolderId == folderId && !d.IsDeleted).ToList())
                    size += folder._Size(folder.pk_FolderId);//Recursively get the size of the children folders.

                foreach (File file in  context.Files.Where(d => d.fk_FolderId == folderId && !d.IsDeleted).ToList())
                    size += file.FileSize;//Get the size of each file

            }
            return size;

        }

        public long FileSize
        {
            get { return _Size(pk_FolderId); } 
        }

        public Guid ParentObject => fk_ParentFolderId??new Guid();
        public Guid FileSystemId => pk_FolderId;
        public string DisplayName => Name;
        public DateTime CreatedDate => CreateDt;
        public DateTime? DeletedDate => DeletedDt;
        public bool ObjectIsDeleted => IsDeleted;
        public SecurityObject DeletedBySecurityObject => DeletedBy;
        public SecurityObject OwnerSecurityObject => Owner;
        public SecurityObject CreatedBySecurityObject => CreatedBy;
        public string FileMimeType => null;
        public bool? FileIsRevisioned => null;
        public Guid? FolderCatalogCollectionId => null;
    }
}
